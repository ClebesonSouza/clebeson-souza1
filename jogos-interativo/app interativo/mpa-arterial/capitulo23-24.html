<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ExtremeCenter (Web)</title>
  <style>
    :root{
      --bg0:#070A12;
      --bg1:#0B1330;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.09);
      --border: rgba(255,255,255,.10);
      --text:#EAF0FF;
      --muted: rgba(234,240,255,.68);
      --brand:#7C5CFF;
      --brand2:#2ED3FF;
      --ok:#33D69F;
      --warn:#FFB020;
      --bad:#FF4D6D;
      --shadow: 0 12px 40px rgba(0,0,0,.45);
      --radius: 18px;
      --radius2: 14px;
      --focus: 0 0 0 3px rgba(46,211,255,.25), 0 0 0 1px rgba(46,211,255,.55);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
      background:
        radial-gradient(900px 600px at 14% 18%, rgba(124,92,255,.26), transparent 62%),
        radial-gradient(900px 600px at 78% 20%, rgba(46,211,255,.18), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow:hidden;
    }

    .app{
      height:100%;
      display:grid;
      grid-template-rows: 68px 1fr;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 18px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      backdrop-filter: blur(10px);
    }

    .brand{
      display:flex; gap:10px; align-items:center;
      min-width: 220px;
    }
    .logo{
      width:38px; height:38px; border-radius: 12px;
      background: linear-gradient(135deg, var(--brand), var(--brand2));
      box-shadow: 0 10px 25px rgba(124,92,255,.22);
    }
    .brand h1{
      font-size:16px; margin:0; letter-spacing:.4px;
    }
    .brand small{
      display:block; margin-top:2px; color:var(--muted); font-size:12px;
    }

    .nav{
      display:flex; gap:10px; align-items:center;
      flex-wrap:wrap;
      justify-content:center;
    }
    .tab{
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      min-width: 110px;
      text-align:center;
      user-select:none;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .tab:hover{ background: rgba(255,255,255,.06); }
    .tab:active{ transform: scale(.99); }
    .tab.active{
      background: linear-gradient(135deg, rgba(124,92,255,.22), rgba(46,211,255,.10));
      border-color: rgba(124,92,255,.55);
    }

    .right{
      display:flex; gap:10px; align-items:center;
      min-width: 220px; justify-content:flex-end;
    }
    .pill{
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      padding: 8px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 12px;
      max-width: 220px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      transition: background .12s ease, transform .08s ease, border-color .12s ease;
    }
    .btn:hover{ background: rgba(255,255,255,.07); }
    .btn.primary{
      border-color: rgba(124,92,255,.6);
      background: linear-gradient(135deg, rgba(124,92,255,.35), rgba(46,211,255,.10));
    }
    .btn.danger{ border-color: rgba(255,77,109,.5); }
    .btn:active{ transform: scale(.99); }

    :focus-visible{
      outline:none;
      box-shadow: var(--focus);
      border-color: rgba(46,211,255,.65) !important;
    }

    main{
      height:100%;
      overflow:hidden;
      display:grid;
      grid-template-columns: 1fr;
    }

    .view{
      height:100%;
      overflow:auto;
      padding: 18px;
    }

    .grid{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 14px;
      height: calc(100vh - 110px);
      align-items:stretch;
    }

    .panel{
      border:1px solid var(--border);
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .panel .hd{
      padding: 14px 14px 12px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.14);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .panel .hd h2{
      margin:0; font-size: 14px; letter-spacing:.25px;
    }
    .panel .bd{
      padding: 12px 14px;
      overflow:auto;
      min-height: 0;
    }

    .search{
      width: 100%;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 11px 12px;
      border-radius: 14px;
      font-size: 14px;
    }
    .muted{ color: var(--muted); }

    .list{
      display:flex; flex-direction:column; gap:8px;
    }
    .item{
      display:flex; gap:10px; align-items:center;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 14px;
      padding: 10px 10px;
      cursor:pointer;
      transition: background .12s ease, border-color .12s ease, transform .08s ease;
    }
    .item:hover{ background: rgba(255,255,255,.05); }
    .item:active{ transform: scale(.995); }
    .item .thumb{
      width: 42px; height: 42px;
      border-radius: 12px;
      background: rgba(255,255,255,.06);
      flex: 0 0 auto;
      overflow:hidden;
      display:grid; place-items:center;
      border:1px solid rgba(255,255,255,.08);
    }
    .item .thumb img{ width:100%; height:100%; object-fit:cover; display:block; }
    .item .meta{ min-width:0; flex:1; }
    .item .meta b{
      display:block;
      font-size: 13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .item .meta small{
      display:block;
      color: var(--muted);
      font-size: 12px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      margin-top:2px;
    }
    .item .actions{
      display:flex; gap:8px; align-items:center;
      flex: 0 0 auto;
    }
    .chip{
      font-size: 11px;
      color: var(--muted);
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      padding: 6px 8px;
      border-radius: 999px;
    }
    .iconbtn{
      width: 38px; height: 38px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      cursor:pointer;
      display:grid; place-items:center;
    }
    .iconbtn.fav.on{
      border-color: rgba(255,176,32,.75);
      background: rgba(255,176,32,.10);
    }

    .row{
      display:flex; gap:12px; align-items:center; flex-wrap:wrap;
    }

    .form{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .field label{
      display:block; font-size: 12px; color: var(--muted);
      margin-bottom: 6px;
    }
    .field input, .field textarea{
      width:100%;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 11px 12px;
      border-radius: 14px;
      font-size: 14px;
    }
    .field textarea{ min-height: 96px; resize: vertical; }

    .status{
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 14px;
      padding: 10px 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .status.ok{ border-color: rgba(51,214,159,.55); background: rgba(51,214,159,.08); color: rgba(234,240,255,.85); }
    .status.bad{ border-color: rgba(255,77,109,.55); background: rgba(255,77,109,.08); color: rgba(234,240,255,.85); }
    .status.warn{ border-color: rgba(255,176,32,.55); background: rgba(255,176,32,.08); color: rgba(234,240,255,.85); }

    /* Player overlay */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.70);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 50;
    }
    .overlay.on{ display:flex; }

    .playerCard{
      width: min(1200px, 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: rgba(10,12,22,.72);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:grid;
      grid-template-rows: auto 1fr auto;
    }
    .playerHd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.18);
    }
    .playerHd .title{
      min-width:0;
    }
    .playerHd b{
      display:block;
      font-size: 14px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .playerHd small{
      display:block;
      margin-top:2px;
      color: var(--muted);
      font-size: 12px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    video{
      width:100%;
      height: min(66vh, 640px);
      background: #000;
    }
    .playerFt{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 12px 14px;
      border-top: 1px solid var(--border);
      background: rgba(0,0,0,.16);
      flex-wrap:wrap;
    }
    .kbdHint{
      color: var(--muted);
      font-size: 12px;
    }

    /* VOD grid */
    .vodGrid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
    }
    .vodCard{
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      overflow:hidden;
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .vodCard:hover{ background: rgba(255,255,255,.05); }
    .vodCard:active{ transform: scale(.995); }
    .vodPoster{
      width:100%; aspect-ratio: 2/3;
      background: rgba(255,255,255,.06);
      display:block;
    }
    .vodPoster img{ width:100%; height:100%; object-fit:cover; display:block; }
    .vodInfo{ padding: 10px 10px 12px 10px; }
    .vodInfo b{
      display:block; font-size: 13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .vodInfo small{ display:block; margin-top:3px; color:var(--muted); font-size:12px; }

    /* Modal unlock */
    .modal{
      position:fixed; inset:0;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.65);
      z-index: 80;
      padding: 18px;
    }
    .modal.on{ display:flex; }
    .modalCard{
      width: min(520px, 100%);
      border:1px solid var(--border);
      border-radius: var(--radius);
      background: rgba(12,14,26,.8);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalCard .hd{ padding:14px; border-bottom:1px solid var(--border); }
    .modalCard .bd{ padding:14px; display:grid; gap:12px; }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>ExtremeCenter</h1>
          <small>IPTV Android ‚Ä¢ M3U + XMLTV ‚Ä¢ Favoritos/Recentes</small>
        </div>
      </div>

      <nav class="nav" aria-label="Navega√ß√£o">
        <button class="tab active" data-view="live">Ao vivo</button>
        <button class="tab" data-view="favorites">Favoritos</button>
        <button class="tab" data-view="recents">Recentes</button>
        <button class="tab" data-view="vod">VOD (JSON)</button>
        <button class="tab" data-view="settings">Config</button>
      </nav>

      <div class="right">
        <div class="pill" id="pillStatus">Pronto</div>
        <button class="btn" id="btnSync">Sincronizar</button>
        <button class="btn danger" id="btnReset">Reset</button>
      </div>
    </header>

    <main>
      <!-- LIVE -->
      <section class="view" id="view-live">
        <div class="grid">
          <div class="panel">
            <div class="hd">
              <h2>Grupos</h2>
              <span class="chip" id="groupsCount">0</span>
            </div>
            <div class="bd">
              <input class="search" id="groupSearch" placeholder="Buscar grupo..." />
              <div style="height:10px"></div>
              <div class="list" id="groupsList"></div>
            </div>
          </div>

          <div class="panel">
            <div class="hd">
              <h2>Canais</h2>
              <div class="row">
                <span class="chip" id="channelsCount">0</span>
                <span class="chip" id="epgHint">EPG: ‚Äî</span>
              </div>
            </div>
            <div class="bd">
              <input class="search" id="channelSearch" placeholder="Buscar canal..." />
              <div style="height:10px"></div>
              <div class="list" id="channelsList"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- FAVORITES -->
      <section class="view" id="view-favorites" style="display:none;">
        <div class="panel" style="height: calc(100vh - 110px);">
          <div class="hd">
            <h2>Favoritos</h2>
            <span class="chip" id="favoritesCount">0</span>
          </div>
          <div class="bd">
            <div class="list" id="favoritesList"></div>
          </div>
        </div>
      </section>

      <!-- RECENTS -->
      <section class="view" id="view-recents" style="display:none;">
        <div class="panel" style="height: calc(100vh - 110px);">
          <div class="hd">
            <h2>Recentes</h2>
            <span class="chip" id="recentsCount">0</span>
          </div>
          <div class="bd">
            <div class="list" id="recentsList"></div>
          </div>
        </div>
      </section>

      <!-- VOD -->
      <section class="view" id="view-vod" style="display:none;">
        <div class="grid" style="grid-template-columns: 360px 1fr;">
          <div class="panel">
            <div class="hd">
              <h2>Fonte VOD (opcional)</h2>
              <span class="chip">JSON</span>
            </div>
            <div class="bd">
              <div class="status warn">
                VOD aqui √© opcional e s√≥ funciona se voc√™ fornecer uma URL JSON pr√≥pria (legal), no formato simples:
                <br><br>
                <code>[{"id":"1","title":"...","type":"movie","poster":"...","streamUrl":"..."}]</code>
              </div>
              <div style="height:12px"></div>
              <button class="btn primary" id="btnSyncVod">Sincronizar VOD</button>
              <button class="btn" id="btnClearVod" style="margin-left:8px;">Limpar cache VOD</button>
              <div style="height:12px"></div>
              <div class="status" id="vodStatus">‚Äî</div>
            </div>
          </div>

          <div class="panel">
            <div class="hd">
              <h2>Cat√°logo</h2>
              <span class="chip" id="vodCount">0</span>
            </div>
            <div class="bd">
              <div class="vodGrid" id="vodGrid"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="view" id="view-settings" style="display:none;">
        <div class="grid" style="grid-template-columns: 420px 1fr;">
          <div class="panel">
            <div class="hd">
              <h2>Configura√ß√µes</h2>
              <span class="chip">localStorage + IndexedDB</span>
            </div>
            <div class="bd">
              <div class="form">
                <div class="field">
                  <label>URL da Playlist (M3U)</label>
                  <input id="inpM3U" placeholder="https://exemplo.com/lista.m3u" />
                </div>
                <div class="field">
                  <label>URL do EPG (XMLTV)</label>
                  <input id="inpEPG" placeholder="https://exemplo.com/epg.xml" />
                </div>
                <div class="field">
                  <label>URL VOD (JSON opcional)</label>
                  <input id="inpVOD" placeholder="https://exemplo.com/vod.json" />
                </div>

                <div class="panel" style="box-shadow:none; background: rgba(255,255,255,.03); border-radius: 16px;">
                  <div class="hd">
                    <h2>Autentica√ß√£o (opcional)</h2>
                    <span class="chip">AES‚ÄëGCM</span>
                  </div>
                  <div class="bd">
                    <div class="status warn">
                      Token ser√° armazenado criptografado no navegador; para m√°xima seguran√ßa, use backend/proxy e evite expor tokens no cliente.
                    </div>
                    <div style="height:10px"></div>
                    <div class="field">
                      <label>Token (Bearer / API key)</label>
                      <input id="inpToken" placeholder="Cole o token aqui (ser√° criptografado ao salvar)" />
                    </div>
                    <div class="field">
                      <label>PIN local (para criptografar/descriptografar)</label>
                      <input id="inpPin" type="password" placeholder="Ex.: 1234" />
                    </div>
                    <div class="row">
                      <button class="btn primary" id="btnSaveToken">Salvar token</button>
                      <button class="btn" id="btnLock">Bloquear (limpar da mem√≥ria)</button>
                      <button class="btn danger" id="btnClearToken">Apagar token</button>
                    </div>
                    <div style="height:10px"></div>
                    <div class="status" id="authStatus">Token: ‚Äî</div>
                  </div>
                </div>

                <div class="row">
                  <button class="btn primary" id="btnSaveSettings">Salvar</button>
                  <button class="btn" id="btnTestUrls">Testar</button>
                </div>

                <div class="status" id="settingsStatus">‚Äî</div>
              </div>
            </div>
          </div>

          <div class="panel">
            <div class="hd">
              <h2>Diagn√≥stico</h2>
              <span class="chip" id="diagChip">‚Äî</span>
            </div>
            <div class="bd">
              <div class="status" id="diagBox">Cole suas URLs e clique em ‚ÄúTestar‚Äù.</div>
              <div style="height:12px"></div>
              <div class="status">
                Dicas:
                <br>‚Ä¢ Se der erro de CORS no navegador, voc√™ vai precisar hospedar este app em um servidor (mesma origem) ou usar uma API que permita CORS.
                <br>‚Ä¢ Alguns streams precisam de headers/autentica√ß√£o e podem falhar em WebView/navegador.
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- PLAYER OVERLAY -->
  <div class="overlay" id="overlay">
    <div class="playerCard">
      <div class="playerHd">
        <div class="title">
          <b id="playTitle">‚Äî</b>
          <small id="playSub">‚Äî</small>
        </div>
        <div class="row">
          <button class="btn" id="btnToggleFav">Favoritar</button>
          <button class="btn danger" id="btnClosePlayer">Fechar</button>
        </div>
      </div>
      <video id="video" controls playsinline></video>
      <div class="playerFt">
        <div class="kbdHint">
          Teclas: Enter = abrir ‚Ä¢ F = favoritar ‚Ä¢ Esc = fechar
        </div>
        <div class="row">
          <span class="chip" id="nowChip">Agora: ‚Äî</span>
          <span class="chip" id="nextChip">Pr√≥ximo: ‚Äî</span>
        </div>
      </div>
    </div>
  </div>

  <!-- UNLOCK MODAL -->
  <div class="modal" id="unlockModal">
    <div class="modalCard">
      <div class="hd">
        <b>Desbloquear token</b>
        <div class="muted" style="font-size:12px; margin-top:4px;">Informe o PIN local para usar headers autenticados nesta sess√£o.</div>
      </div>
      <div class="bd">
        <div class="field">
          <label>PIN</label>
          <input id="unlockPin" type="password" placeholder="Digite seu PIN" />
        </div>
        <div class="row">
          <button class="btn primary" id="btnUnlock">Desbloquear</button>
          <button class="btn" id="btnUnlockSkip">Agora n√£o</button>
        </div>
        <div class="status" id="unlockStatus">‚Äî</div>
      </div>
    </div>
  </div>

  <!-- Optional: hls.js (descomente se precisar de HLS via MSE) -->
  <!-- <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script> -->

  <script>
    /***********************
     * EXTREMECENTER WEB
     * - Settings: localStorage (DataStore-like)
     * - Cache: IndexedDB (Room-like)
     * - Token: WebCrypto AES-GCM + PBKDF2 (best-effort client-side)
     ************************/

    const APP = {
      settingsKey: "ec_settings_v2",
      legacyKeys: { m3u: "playlist_url", epg: "epg_url", vod: "vod_url" },
      secureTokenKey: "ec_secure_token_v1",   // {salt, iv, ct, iters}
      sessionToken: null, // decrypted token kept only in memory
      db: null,
      state: {
        view: "live",
        settings: { m3uUrl:"", epgUrl:"", vodUrl:"" },
        channels: [],
        groups: [],
        groupSelected: "Todos",
        epgByChannel: new Map(), // channelId -> programs (today-ish)
        vodItems: [],
        playing: null, // current item
      }
    };

    /***************
     * Utilities
     ***************/
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    function setPill(text, tone="") {
      const el = $("#pillStatus");
      el.textContent = text;
      el.style.borderColor = "var(--border)";
      el.style.background = "rgba(255,255,255,.04)";
      if (tone === "ok") { el.style.borderColor = "rgba(51,214,159,.55)"; el.style.background = "rgba(51,214,159,.08)"; }
      if (tone === "bad"){ el.style.borderColor = "rgba(255,77,109,.55)"; el.style.background = "rgba(255,77,109,.08)"; }
      if (tone === "warn"){ el.style.borderColor = "rgba(255,176,32,.55)"; el.style.background = "rgba(255,176,32,.08)"; }
    }

    function escHtml(s="") {
      return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
    }

    function normalizeId(str) {
      return (str || "").trim().toLowerCase().replace(/\s+/g, " ").slice(0, 160);
    }

    function nowMs(){ return Date.now(); }
    function fmtTime(ms){
      const d = new Date(ms);
      const hh = String(d.getHours()).padStart(2,"0");
      const mm = String(d.getMinutes()).padStart(2,"0");
      return `${hh}:${mm}`;
    }

    /***************
     * Storage (DataStore-like)
     ***************/
    function migrateLegacySettings() {
      // Local migration: old localStorage keys -> new JSON blob
      const legacyM3U = localStorage.getItem(APP.legacyKeys.m3u);
      const legacyEPG = localStorage.getItem(APP.legacyKeys.epg);
      const legacyVOD = localStorage.getItem(APP.legacyKeys.vod);

      const hasLegacy = legacyM3U || legacyEPG || legacyVOD;
      if (!hasLegacy) return;

      const current = loadSettings();
      const merged = {
        ...current,
        m3uUrl: current.m3uUrl || (legacyM3U || ""),
        epgUrl: current.epgUrl || (legacyEPG || ""),
        vodUrl: current.vodUrl || (legacyVOD || "")
      };

      saveSettings(merged);

      // Optionally remove legacy keys
      localStorage.removeItem(APP.legacyKeys.m3u);
      localStorage.removeItem(APP.legacyKeys.epg);
      localStorage.removeItem(APP.legacyKeys.vod);
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(APP.settingsKey);
        if (!raw) return { m3uUrl:"", epgUrl:"", vodUrl:"" };
        const obj = JSON.parse(raw);
        return { m3uUrl: obj.m3uUrl || "", epgUrl: obj.epgUrl || "", vodUrl: obj.vodUrl || "" };
      } catch {
        return { m3uUrl:"", epgUrl:"", vodUrl:"" };
      }
    }

    function saveSettings(s) {
      localStorage.setItem(APP.settingsKey, JSON.stringify({
        m3uUrl: (s.m3uUrl||"").trim(),
        epgUrl: (s.epgUrl||"").trim(),
        vodUrl: (s.vodUrl||"").trim(),
        savedAt: nowMs()
      }));
    }

    /***************
     * IndexedDB (Room-like)
     ***************/
    function openDb() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open("ExtremeCenterDB", 1);
        req.onupgradeneeded = (e) => {
          const db = req.result;
          db.createObjectStore("channels", { keyPath: "id" });
          db.createObjectStore("epg", { keyPath: "key" }); // key = channelId|YYYYMMDD
          db.createObjectStore("favorites", { keyPath: "id" }); // id = channelId
          db.createObjectStore("recents", { keyPath: "id" });   // id = channelId
          db.createObjectStore("vod", { keyPath: "id" });
          db.createObjectStore("meta", { keyPath: "key" });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    function tx(storeName, mode="readonly") {
      const t = APP.db.transaction(storeName, mode);
      return { store: t.objectStore(storeName), done: new Promise((res, rej) => { t.oncomplete=res; t.onerror=()=>rej(t.error); }) };
    }

    async function putMany(storeName, items) {
      const { store, done } = tx(storeName, "readwrite");
      items.forEach(it => store.put(it));
      await done;
    }
    async function getAll(storeName) {
      const { store, done } = tx(storeName, "readonly");
      const req = store.getAll();
      const out = await new Promise((res, rej) => {
        req.onsuccess = () => res(req.result || []);
        req.onerror = () => rej(req.error);
      });
      await done;
      return out;
    }
    async function getOne(storeName, key) {
      const { store, done } = tx(storeName, "readonly");
      const req = store.get(key);
      const out = await new Promise((res, rej) => {
        req.onsuccess = () => res(req.result || null);
        req.onerror = () => rej(req.error);
      });
      await done;
      return out;
    }
    async function delOne(storeName, key) {
      const { store, done } = tx(storeName, "readwrite");
      store.delete(key);
      await done;
    }
    async function clearStore(storeName) {
      const { store, done } = tx(storeName, "readwrite");
      store.clear();
      await done;
    }

    /***************
     * Crypto token store (best-effort)
     ***************/
    function b64(buf) {
      const bytes = new Uint8Array(buf);
      let s = "";
      for (const b of bytes) s += String.fromCharCode(b);
      return btoa(s);
    }
    function unb64(s) {
      const bin = atob(s);
      const bytes = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
      return bytes.buffer;
    }
    async function deriveKeyFromPin(pin, saltBuf, iters=120000) {
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey("raw", enc.encode(pin), "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey(
        { name:"PBKDF2", salt: new Uint8Array(saltBuf), iterations: iters, hash:"SHA-256" },
        baseKey,
        { name:"AES-GCM", length: 256 },
        false,
        ["encrypt","decrypt"]
      );
    }

    async function encryptToken(token, pin) {
      const salt = crypto.getRandomValues(new Uint8Array(16)).buffer;
      const iv = crypto.getRandomValues(new Uint8Array(12)).buffer;
      const iters = 120000;
      const key = await deriveKeyFromPin(pin, salt, iters);
      const enc = new TextEncoder();
      const ct = await crypto.subtle.encrypt({ name:"AES-GCM", iv: new Uint8Array(iv) }, key, enc.encode(token));
      return { salt: b64(salt), iv: b64(iv), ct: b64(ct), iters };
    }

    async function decryptToken(blob, pin) {
      const salt = unb64(blob.salt);
      const iv = unb64(blob.iv);
      const ct = unb64(blob.ct);
      const iters = blob.iters || 120000;
      const key = await deriveKeyFromPin(pin, salt, iters);
      const pt = await crypto.subtle.decrypt({ name:"AES-GCM", iv: new Uint8Array(iv) }, key, ct);
      return new TextDecoder().decode(pt);
    }

    function hasEncryptedToken() {
      return !!localStorage.getItem(APP.secureTokenKey);
    }

    function readEncryptedTokenBlob() {
      try { return JSON.parse(localStorage.getItem(APP.secureTokenKey) || "null"); }
      catch { return null; }
    }

    function setEncryptedTokenBlob(blob) {
      localStorage.setItem(APP.secureTokenKey, JSON.stringify(blob));
    }

    function clearEncryptedToken() {
      localStorage.removeItem(APP.secureTokenKey);
      APP.sessionToken = null;
    }

    /***************
     * Networking
     ***************/
    function authHeaders() {
      const token = APP.sessionToken;
      if (!token) return {};
      // Minimal: Bearer token. Ajuste se sua API exigir outro header.
      return { "Authorization": `Bearer ${token}` };
    }

    async function fetchText(url) {
      const res = await fetch(url, { headers: { ...authHeaders() } });
      if (!res.ok) throw new Error(`HTTP ${res.status} ao baixar: ${url}`);
      return res.text();
    }

    async function fetchJson(url) {
      const res = await fetch(url, { headers: { ...authHeaders() } });
      if (!res.ok) throw new Error(`HTTP ${res.status} ao baixar: ${url}`);
      return res.json();
    }

    /***************
     * Parsing: M3U
     * Common attrs: tvg-id, tvg-name, tvg-logo, group-title [web:243]
     ***************/
    function parseExtinfAttrs(line) {
      // line like: #EXTINF:-1 tvg-id="x" tvg-logo="y" group-title="News",Channel Name
      const attrs = {};
      const m = line.match(/#EXTINF:[^,]*\s*(.*?),/);
      const left = m ? m[1] : "";
      const name = line.includes(",") ? line.split(",").slice(1).join(",").trim() : "";
      attrs._display = name;

      const re = /([a-zA-Z0-9_-]+)="([^"]*)"/g;
      let mm;
      while ((mm = re.exec(left)) !== null) {
        attrs[mm[1]] = mm[2];
      }
      // Sometimes group is after comma via #EXTGRP; ignore for now
      return attrs;
    }

    function parseM3U(text) {
      const lines = text.replace(/\r/g,"").split("\n").map(l => l.trim()).filter(Boolean);
      const channels = [];
      let pending = null;

      for (const line of lines) {
        if (line.startsWith("#EXTINF:")) {
          const a = parseExtinfAttrs(line);
          pending = a;
          continue;
        }
        if (line.startsWith("#")) continue; // skip tags
        // stream/url line
        if (pending) {
          const tvgId = (pending["tvg-id"] || pending["tvg-name"] || pending._display || "").trim();
          const name = (pending._display || pending["tvg-name"] || tvgId || "Canal").trim();
          const group = (pending["group-title"] || "Sem grupo").trim();
          const logo = (pending["tvg-logo"] || "").trim();
          const url = line.trim();

          const id = normalizeId(tvgId) || normalizeId(name) || normalizeId(url);
          channels.push({
            id, name, group, logo, url,
            tvgId: (pending["tvg-id"] || "").trim(),
            tvgName: (pending["tvg-name"] || "").trim(),
          });
          pending = null;
        }
      }
      return channels;
    }

    /***************
     * Parsing: XMLTV
     * - channel id attribute, programme elements with channel/start/stop are typical [web:246]
     ***************/
    function parseXmltvDate(s) {
      // XMLTV often uses YYYYMMDDhhmmss +/-ZZZZ
      // We'll parse first 14 digits as local time (best-effort).
      if (!s) return null;
      const core = s.slice(0,14);
      if (!/^\d{14}$/.test(core)) return null;
      const y = +core.slice(0,4), mo = +core.slice(4,6)-1, d = +core.slice(6,8);
      const h = +core.slice(8,10), mi = +core.slice(10,12), se = +core.slice(12,14);
      return new Date(y, mo, d, h, mi, se).getTime();
    }

    function parseXMLTV(xmlText) {
      const doc = new DOMParser().parseFromString(xmlText, "text/xml");
      const parseError = doc.querySelector("parsererror");
      if (parseError) throw new Error("XML inv√°lido (XMLTV)");

      const programsByChannel = new Map();
      const progs = Array.from(doc.querySelectorAll("programme"));
      for (const p of progs) {
        const ch = p.getAttribute("channel") || "";
        const start = parseXmltvDate(p.getAttribute("start"));
        const stop = parseXmltvDate(p.getAttribute("stop"));
        const title = (p.querySelector("title")?.textContent || "").trim();
        const desc = (p.querySelector("desc")?.textContent || "").trim();
        const cat = (p.querySelector("category")?.textContent || "").trim();

        if (!ch || !start) continue;
        const item = { start, stop, title, desc, cat };

        if (!programsByChannel.has(ch)) programsByChannel.set(ch, []);
        programsByChannel.get(ch).push(item);
      }

      // sort by start
      for (const [k, arr] of programsByChannel.entries()) {
        arr.sort((a,b)=>a.start-b.start);
      }
      return programsByChannel;
    }

    function epgNowNext(channelId) {
      const arr = APP.state.epgByChannel.get(channelId) || [];
      const t = nowMs();
      let nowItem = null, nextItem = null;
      for (let i=0;i<arr.length;i++){
        const it = arr[i];
        const end = it.stop || (it.start + 30*60*1000);
        if (t >= it.start && t < end) {
          nowItem = it;
          nextItem = arr[i+1] || null;
          break;
        }
        if (it.start > t) { nextItem = it; break; }
      }
      return { nowItem, nextItem };
    }

    /***************
     * UI rendering
     ***************/
    function setView(view) {
      APP.state.view = view;
      $$(".tab").forEach(b => b.classList.toggle("active", b.dataset.view === view));
      ["live","favorites","recents","vod","settings"].forEach(v => {
        $("#view-"+v).style.display = (v===view) ? "" : "none";
      });
      if (view === "favorites") renderFavorites();
      if (view === "recents") renderRecents();
      if (view === "vod") renderVod();
      if (view === "settings") renderSettings();
    }

    function renderGroups() {
      const list = $("#groupsList");
      const q = ($("#groupSearch").value || "").trim().toLowerCase();
      const groups = ["Todos", ...APP.state.groups].filter(g => g.toLowerCase().includes(q));
      $("#groupsCount").textContent = String(groups.length);

      list.innerHTML = groups.map(g => `
        <div class="item" tabindex="0" data-group="${escHtml(g)}" style="${g===APP.state.groupSelected ? 'border-color: rgba(124,92,255,.6); background: rgba(124,92,255,.10);' : ''}">
          <div class="thumb" aria-hidden="true">üìÅ</div>
          <div class="meta">
            <b>${escHtml(g)}</b>
            <small>${g==="Todos" ? "Exibir todos os canais" : "Filtrar por grupo"}</small>
          </div>
          <div class="actions"><span class="chip">Enter</span></div>
        </div>
      `).join("");

      list.querySelectorAll(".item").forEach(el=>{
        el.addEventListener("click", ()=>{ APP.state.groupSelected = el.dataset.group; renderChannels(); renderGroups(); });
        el.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ el.click(); } });
      });
    }

    async function isFavorite(channelId) {
      const it = await getOne("favorites", channelId);
      return !!it;
    }

    async function toggleFavorite(channel) {
      const fav = await getOne("favorites", channel.id);
      if (fav) await delOne("favorites", channel.id);
      else await putMany("favorites", [{ id: channel.id, name: channel.name, group: channel.group, logo: channel.logo, url: channel.url, at: nowMs() }]);
      if (APP.state.view === "favorites") renderFavorites();
    }

    async function markRecent(channel) {
      await putMany("recents", [{ id: channel.id, name: channel.name, group: channel.group, logo: channel.logo, url: channel.url, at: nowMs() }]);
      if (APP.state.view === "recents") renderRecents();
    }

    function renderChannels() {
      const list = $("#channelsList");
      const q = ($("#channelSearch").value || "").trim().toLowerCase();

      let channels = APP.state.channels;
      if (APP.state.groupSelected !== "Todos") channels = channels.filter(c => c.group === APP.state.groupSelected);
      if (q) channels = channels.filter(c => (c.name||"").toLowerCase().includes(q) || (c.group||"").toLowerCase().includes(q));

      $("#channelsCount").textContent = String(channels.length);
      $("#epgHint").textContent = APP.state.epgByChannel.size ? "EPG: OK" : "EPG: ‚Äî";

      list.innerHTML = channels.slice(0, 500).map(c => `
        <div class="item" tabindex="0" data-id="${escHtml(c.id)}">
          <div class="thumb">${c.logo ? `<img src="${escHtml(c.logo)}" alt="">` : "üì∫"}</div>
          <div class="meta">
            <b>${escHtml(c.name)}</b>
            <small>${escHtml(c.group)} ‚Ä¢ ${escHtml(c.url)}</small>
          </div>
          <div class="actions">
            <button class="iconbtn fav" title="Favoritar" aria-label="Favoritar">‚òÖ</button>
            <span class="chip">Enter</span>
          </div>
        </div>
      `).join("");

      list.querySelectorAll(".item").forEach(el => {
        const id = el.dataset.id;
        const channel = APP.state.channels.find(x => x.id === id);

        el.addEventListener("click", () => openPlayerChannel(channel));
        el.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ el.click(); } });

        const favBtn = el.querySelector(".fav");
        favBtn.addEventListener("click", async (e)=>{
          e.stopPropagation();
          await toggleFavorite(channel);
          await updateFavButton(favBtn, channel.id);
        });

        updateFavButton(favBtn, channel.id);
      });
    }

    async function updateFavButton(btn, channelId) {
      const fav = await isFavorite(channelId);
      btn.classList.toggle("on", fav);
      btn.textContent = fav ? "‚òÖ" : "‚òÜ";
    }

    async function renderFavorites() {
      const list = $("#favoritesList");
      const favs = await getAll("favorites");
      favs.sort((a,b)=>(b.at||0)-(a.at||0));
      $("#favoritesCount").textContent = String(favs.length);

      list.innerHTML = favs.map(c => `
        <div class="item" tabindex="0" data-id="${escHtml(c.id)}">
          <div class="thumb">${c.logo ? `<img src="${escHtml(c.logo)}" alt="">` : "‚òÖ"}</div>
          <div class="meta">
            <b>${escHtml(c.name)}</b>
            <small>${escHtml(c.group || "‚Äî")}</small>
          </div>
          <div class="actions">
            <button class="iconbtn" title="Remover" aria-label="Remover">üóë</button>
            <span class="chip">Enter</span>
          </div>
        </div>
      `).join("");

      list.querySelectorAll(".item").forEach(el => {
        const id = el.dataset.id;
        const item = favs.find(x=>x.id===id);
        el.addEventListener("click", ()=> openPlayerChannel(item));
        el.addEventListener("keydown",(e)=>{ if(e.key==="Enter") el.click(); });

        el.querySelector("button").addEventListener("click", async (e)=>{
          e.stopPropagation();
          await delOne("favorites", id);
          renderFavorites();
        });
      });
    }

    async function renderRecents() {
      const list = $("#recentsList");
      const rec = await getAll("recents");
      rec.sort((a,b)=>(b.at||0)-(a.at||0));
      const trimmed = rec.slice(0, 20);
      $("#recentsCount").textContent = String(trimmed.length);

      list.innerHTML = trimmed.map(c => `
        <div class="item" tabindex="0" data-id="${escHtml(c.id)}">
          <div class="thumb">${c.logo ? `<img src="${escHtml(c.logo)}" alt="">` : "üïí"}</div>
          <div class="meta">
            <b>${escHtml(c.name)}</b>
            <small>Visto √†s ${fmtTime(c.at||0)} ‚Ä¢ ${escHtml(c.group||"‚Äî")}</small>
          </div>
          <div class="actions">
            <button class="iconbtn" title="Remover" aria-label="Remover">üóë</button>
            <span class="chip">Enter</span>
          </div>
        </div>
      `).join("");

      list.querySelectorAll(".item").forEach(el => {
        const id = el.dataset.id;
        const item = trimmed.find(x=>x.id===id);
        el.addEventListener("click", ()=> openPlayerChannel(item));
        el.addEventListener("keydown",(e)=>{ if(e.key==="Enter") el.click(); });

        el.querySelector("button").addEventListener("click", async (e)=>{
          e.stopPropagation();
          await delOne("recents", id);
          renderRecents();
        });
      });
    }

    function renderSettings() {
      $("#inpM3U").value = APP.state.settings.m3uUrl;
      $("#inpEPG").value = APP.state.settings.epgUrl;
      $("#inpVOD").value = APP.state.settings.vodUrl;

      $("#settingsStatus").textContent = "‚Äî";
      $("#diagChip").textContent = hasEncryptedToken() ? "Token criptografado: SIM" : "Token criptografado: N√ÉO";
      $("#authStatus").textContent = `Token: ${hasEncryptedToken() ? "SALVO (criptografado)" : "‚Äî"} ‚Ä¢ Em mem√≥ria: ${APP.sessionToken ? "SIM" : "N√ÉO"}`;
    }

    async function renderVod() {
      const items = await getAll("vod");
      items.sort((a,b)=>(b.updatedAt||0)-(a.updatedAt||0));
      APP.state.vodItems = items;

      $("#vodCount").textContent = String(items.length);
      $("#vodGrid").innerHTML = items.map(it => `
        <div class="vodCard" tabindex="0" data-id="${escHtml(it.id)}">
          <div class="vodPoster">${it.poster ? `<img src="${escHtml(it.poster)}" alt="">` : ""}</div>
          <div class="vodInfo">
            <b>${escHtml(it.title || "Sem t√≠tulo")}</b>
            <small>${escHtml(it.type || "VOD")}</small>
          </div>
        </div>
      `).join("");

      $("#vodGrid").querySelectorAll(".vodCard").forEach(el => {
        const id = el.dataset.id;
        const item = items.find(x=>x.id===id);
        el.addEventListener("click", ()=> openPlayerVOD(item));
        el.addEventListener("keydown",(e)=>{ if(e.key==="Enter") el.click(); });
      });
    }

    /***************
     * Player
     ***************/
    async function openPlayerChannel(channel) {
      if (!channel) return;
      APP.state.playing = { kind:"channel", ...channel };
      $("#overlay").classList.add("on");
      $("#playTitle").textContent = channel.name;
      $("#playSub").textContent = channel.group || "Ao vivo";

      const { nowItem, nextItem } = epgNowNext(channel.tvgId || channel.id);
      $("#nowChip").textContent = nowItem ? `Agora: ${nowItem.title || "‚Äî"}` : "Agora: ‚Äî";
      $("#nextChip").textContent = nextItem ? `Pr√≥ximo: ${nextItem.title || "‚Äî"}` : "Pr√≥ximo: ‚Äî";

      await markRecent(channel);
      await updatePlayerFavButton(channel.id);
      await playUrl(channel.url);
    }

    async function openPlayerVOD(item) {
      if (!item) return;
      APP.state.playing = { kind:"vod", ...item };
      $("#overlay").classList.add("on");
      $("#playTitle").textContent = item.title || "VOD";
      $("#playSub").textContent = item.type || "‚Äî";
      $("#nowChip").textContent = "Agora: ‚Äî";
      $("#nextChip").textContent = "Pr√≥ximo: ‚Äî";
      $("#btnToggleFav").style.display = "none"; // favorites for channels only (simplify)
      await playUrl(item.streamUrl);
    }

    async function updatePlayerFavButton(channelId) {
      $("#btnToggleFav").style.display = "";
      const fav = await isFavorite(channelId);
      $("#btnToggleFav").textContent = fav ? "Remover favorito" : "Favoritar";
    }

    async function playUrl(url) {
      const v = $("#video");
      // Reset
      try { v.pause(); } catch {}
      v.removeAttribute("src");
      v.load();

      // Basic attempt: native playback
      v.src = url;
      try {
        await v.play();
        setPill("Reproduzindo", "ok");
      } catch (e) {
        setPill("Falha ao tocar (ver CORS/codec/HLS)", "bad");
        // Optional HLS.js support if loaded:
        // if (window.Hls && window.Hls.isSupported() && url.includes(".m3u8")) { ... }
      }
    }

    function closePlayer() {
      const v = $("#video");
      try { v.pause(); } catch {}
      $("#overlay").classList.remove("on");
      $("#btnToggleFav").style.display = "";
      APP.state.playing = null;
    }

    /***************
     * Sync logic
     ***************/
    function buildGroups(channels) {
      const set = new Set();
      channels.forEach(c => set.add(c.group || "Sem grupo"));
      return Array.from(set).sort((a,b)=>a.localeCompare(b));
    }

    async function syncAll() {
      const { m3uUrl, epgUrl } = APP.state.settings;

      if (!m3uUrl) {
        setPill("Configure a URL M3U", "warn");
        setView("settings");
        return;
      }

      setPill("Baixando M3U...", "warn");
      const m3uText = await fetchText(m3uUrl);
      const channels = parseM3U(m3uText);

      APP.state.channels = channels;
      APP.state.groups = buildGroups(channels);
      APP.state.groupSelected = "Todos";

      await putMany("channels", channels);
      await putMany("meta", [{ key:"last_m3u_sync", at: nowMs(), count: channels.length }]);

      if (epgUrl) {
        setPill("Baixando EPG...", "warn");
        try {
          const xml = await fetchText(epgUrl);
          const epgMap = parseXMLTV(xml);
          APP.state.epgByChannel = epgMap;
          await putMany("meta", [{ key:"last_epg_sync", at: nowMs(), count: epgMap.size }]);
          setPill("Sincronizado (M3U + EPG)", "ok");
        } catch (e) {
          APP.state.epgByChannel = new Map();
          setPill("M3U OK, EPG falhou", "warn");
        }
      } else {
        APP.state.epgByChannel = new Map();
        setPill("Sincronizado (M3U)", "ok");
      }

      if (APP.state.view !== "live") setView("live");
      renderGroups();
      renderChannels();
    }

    async function syncVod() {
      const url = APP.state.settings.vodUrl;
      if (!url) { $("#vodStatus").textContent = "Configure a URL VOD (JSON) em Config."; return; }
      $("#vodStatus").textContent = "Baixando VOD...";
      try {
        const json = await fetchJson(url);
        if (!Array.isArray(json)) throw new Error("JSON deve ser um array");
        const items = json.map(it => ({
          id: String(it.id || normalizeId(it.title) || crypto.randomUUID()),
          title: String(it.title || "Sem t√≠tulo"),
          type: String(it.type || "vod"),
          poster: it.poster ? String(it.poster) : "",
          streamUrl: String(it.streamUrl || ""),
          updatedAt: nowMs()
        })).filter(it => it.streamUrl);

        await putMany("vod", items);
        $("#vodStatus").textContent = `OK: ${items.length} itens em cache.`;
        renderVod();
      } catch (e) {
        $("#vodStatus").textContent = `Erro VOD: ${e.message}`;
      }
    }

    /***************
     * Test URLs
     ***************/
    async function testUrls(m3uUrl, epgUrl) {
      const diag = $("#diagBox");
      $("#diagChip").textContent = "Testando...";
      diag.className = "status warn";
      diag.textContent = "Testando download/parsing...";

      try {
        const t1 = await fetchText(m3uUrl);
        const ch = parseM3U(t1);

        let epgCount = 0;
        if (epgUrl) {
          const t2 = await fetchText(epgUrl);
          const epg = parseXMLTV(t2);
          epgCount = epg.size;
        }

        diag.className = "status ok";
        diag.innerHTML = `OK.<br>M3U: ${ch.length} canais.<br>EPG: ${epgUrl ? (epgCount + " canais com programa√ß√£o") : "n√£o configurado"}.`;
        $("#diagChip").textContent = "OK";
      } catch (e) {
        diag.className = "status bad";
        diag.textContent = "Erro: " + e.message;
        $("#diagChip").textContent = "Falhou";
      }
    }

    /***************
     * Events
     ***************/
    function wireEvents() {
      $$(".tab").forEach(b => b.addEventListener("click", ()=> setView(b.dataset.view)));
      $("#groupSearch").addEventListener("input", renderGroups);
      $("#channelSearch").addEventListener("input", renderChannels);

      $("#btnClosePlayer").addEventListener("click", closePlayer);
      $("#overlay").addEventListener("click", (e)=>{ if (e.target.id === "overlay") closePlayer(); });

      $("#btnToggleFav").addEventListener("click", async ()=>{
        if (!APP.state.playing || APP.state.playing.kind !== "channel") return;
        await toggleFavorite(APP.state.playing);
        await updatePlayerFavButton(APP.state.playing.id);
      });

      $("#btnSync").addEventListener("click", async ()=>{
        try { await syncAll(); } catch(e){ setPill(e.message, "bad"); }
      });

      $("#btnReset").addEventListener("click", async ()=>{
        if (!confirm("Resetar tudo (settings + cache)?")) return;
        localStorage.removeItem(APP.settingsKey);
        clearEncryptedToken();
        await clearStore("channels");
        await clearStore("epg");
        await clearStore("favorites");
        await clearStore("recents");
        await clearStore("vod");
        await clearStore("meta");
        location.reload();
      });

      $("#btnSaveSettings").addEventListener("click", ()=>{
        const s = {
          m3uUrl: $("#inpM3U").value,
          epgUrl: $("#inpEPG").value,
          vodUrl: $("#inpVOD").value
        };
        saveSettings(s);
        APP.state.settings = s;
        $("#settingsStatus").className = "status ok";
        $("#settingsStatus").textContent = "Configura√ß√µes salvas.";
        setPill("Config salva", "ok");
      });

      $("#btnTestUrls").addEventListener("click", async ()=>{
        const m3u = $("#inpM3U").value.trim();
        const epg = $("#inpEPG").value.trim();
        if (!m3u) { $("#settingsStatus").className="status warn"; $("#settingsStatus").textContent="Informe a URL M3U."; return; }
        await testUrls(m3u, epg);
      });

      $("#btnSaveToken").addEventListener("click", async ()=>{
        const token = $("#inpToken").value.trim();
        const pin = $("#inpPin").value.trim();
        if (!token || !pin) { $("#authStatus").className="status warn"; $("#authStatus").textContent="Informe token e PIN."; return; }
        try {
          const blob = await encryptToken(token, pin);
          setEncryptedTokenBlob(blob);
          APP.sessionToken = token;
          $("#inpToken").value = "";
          $("#inpPin").value = "";
          $("#authStatus").className="status ok";
          $("#authStatus").textContent="Token salvo (criptografado) e liberado nesta sess√£o.";
          $("#diagChip").textContent = "Token criptografado: SIM";
        } catch(e) {
          $("#authStatus").className="status bad";
          $("#authStatus").textContent="Erro ao criptografar: " + e.message;
        }
      });

      $("#btnLock").addEventListener("click", ()=>{
        APP.sessionToken = null;
        $("#authStatus").className="status";
        $("#authStatus").textContent="Bloqueado: token removido da mem√≥ria (criptografado permanece salvo).";
      });

      $("#btnClearToken").addEventListener("click", ()=>{
        clearEncryptedToken();
        $("#authStatus").className="status";
        $("#authStatus").textContent="Token apagado.";
        $("#diagChip").textContent = "Token criptografado: N√ÉO";
      });

      $("#btnSyncVod").addEventListener("click", syncVod);
      $("#btnClearVod").addEventListener("click", async ()=>{
        await clearStore("vod");
        $("#vodStatus").textContent = "Cache VOD limpo.";
        renderVod();
      });

      // Keyboard shortcuts
      window.addEventListener("keydown", async (e)=>{
        if ($("#overlay").classList.contains("on")) {
          if (e.key === "Escape") closePlayer();
          if (e.key.toLowerCase() === "f") {
            if (APP.state.playing?.kind === "channel") {
              await toggleFavorite(APP.state.playing);
              await updatePlayerFavButton(APP.state.playing.id);
            }
          }
        }
      });

      // Unlock modal
      $("#btnUnlock").addEventListener("click", async ()=>{
        const pin = $("#unlockPin").value.trim();
        const blob = readEncryptedTokenBlob();
        if (!blob || !pin) return;
        try {
          APP.sessionToken = await decryptToken(blob, pin);
          $("#unlockStatus").className="status ok";
          $("#unlockStatus").textContent="Desbloqueado para esta sess√£o.";
          await sleep(500);
          $("#unlockModal").classList.remove("on");
        } catch(e) {
          $("#unlockStatus").className="status bad";
          $("#unlockStatus").textContent="PIN inv√°lido ou dados corrompidos.";
        }
      });
      $("#btnUnlockSkip").addEventListener("click", ()=> $("#unlockModal").classList.remove("on"));
    }

    /***************
     * Boot
     ***************/
    async function boot() {
      setPill("Iniciando...", "warn");
      migrateLegacySettings();

      APP.db = await openDb();

      APP.state.settings = loadSettings();
      APP.state.channels = await getAll("channels");
      APP.state.groups = buildGroups(APP.state.channels);

      // If token saved, ask to unlock (optional)
      if (hasEncryptedToken()) {
        $("#unlockModal").classList.add("on");
        $("#unlockStatus").textContent = "‚Äî";
      }

      wireEvents();
      renderGroups();
      renderChannels();
      setPill("Pronto", "ok");
    }

    boot().catch(e => {
      setPill("Erro ao iniciar", "bad");
      console.error(e);
      alert("Erro ao iniciar: " + e.message);
    });
  </script>
</body>
</html>
